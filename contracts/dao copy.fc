
;; ops
const OP::NEW_PROPOSAL = 0x1;
const OP::UPDATE_DAO_SETTINGS = 0x2;

;; modes
const MODE::SEND_MODE_REMAINING_AMOUNT = 64;

;; errors
const ERROR::UNAUTHORIZED_SENDER = 0x2000;


(slice, int, int, slice, cell, cell) load_data() inline {
  var ds = get_data().begin_parse();
  return 
    (ds~load_msg_addr(),  ;; registry_address
     ds~load_uint(64),    ;; dao_id
     ds~load_uint(64),    ;; next_proposal_id
     ds~load_msg_addr(),  ;; owner_address
     ds~load_ref(),       ;; dao_settings
     ds~load_ref()        ;; proposal_code
     );
}

() save_data(slice registry_address, int dao_id, int next_proposal_id, slice owner_address, cell dao_settings, cell proposal_code) impure inline {
  set_data(begin_cell()
    .store_slice(registry_address)
    .store_uint(dao_id, 64)
    .store_uint(next_proposal_id, 64)
    .store_slice(owner_address)
    .store_ref(dao_settings)
    .store_ref(proposal_code)
    .end_cell());
}

cell calculate_proposal_state_init(int dao_id, int proposal_index, cell proposal_code, int proposal_start_time, int proposal_end_time, 
  int proposal_snapshot_time, int proposal_type, int voting_power_strategy) {

  cell data = begin_cell().store_uint(dao_id, 64)
                          .store_uint(proposal_index, 64)
                          .store_uint(proposal_start_time, 64)
                          .store_uint(proposal_end_time, 64)
                          .store_uint(proposal_snapshot_time, 64)
                          .store_uint(proposal_type, 8)
                          .store_uint(voting_power_strategy, 8)
              .end_cell();
  return begin_cell().store_uint(0, 2).store_dict(proposal_code).store_dict(data).store_uint(0, 1).end_cell();
}

slice calculate_proposal_address(int wc, cell state_init) {
  return begin_cell().store_uint(4, 3)
                     .store_int(wc, 8)
                     .store_uint(cell_hash(state_init), 256)
                     .end_cell()
                     .begin_parse();
}

() deploy_proposal(int dao_id, int next_proposal_id, cell proposal_code, int proposal_start_time, int proposal_end_time, 
  int proposal_snapshot_time, int proposal_type, int voting_power_strategy) impure {

  cell state_init = calculate_proposal_state_init(dao_id, next_proposal_id, proposal_code, proposal_start_time, proposal_end_time, 
                                                  proposal_snapshot_time, proposal_type, voting_power_strategy);
  slice proposal_address = calculate_proposal_address(0, state_init);
  var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(proposal_address)
            .store_coins(0)
            .store_uint(4 + 2 + 0, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1) ;; send state_init with body in this cell
            .store_ref(state_init);
  send_raw_message(msg.end_cell(), MODE::SEND_MODE_REMAINING_AMOUNT); ;; sender pays gas fees
}

() send_opcode(slice dest, int op) {

  var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(dest)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op, 32); ;; opcode

  send_raw_message(msg.end_cell(), MODE::SEND_MODE_REMAINING_AMOUNT); ;; sender pays gas fees

}

() recv_internal(cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    int op = in_msg_body~load_uint(32);

    var (registry_address, dao_id, next_proposal_id, owner_address, dao_settings, proposal_code) = load_data();

    slice sender_address = cs~load_msg_addr();
    throw_unless(ERROR::UNAUTHORIZED_SENDER, equal_slice_bits(sender_address, owner_address));

    if (op == OP::NEW_PROPOSAL) { ;; create new proposal

      int proposal_start_time = in_msg_body~load_uint(64);
      int proposal_end_time = in_msg_body~load_uint(64);
      int proposal_snapshot_time = in_msg_body~load_uint(64);
      int proposal_type = in_msg_body~load_uint(8);
      int voting_power_strategy = in_msg_body~load_uint(8);

      deploy_proposal(dao_id, next_proposal_id, proposal_code, proposal_start_time, proposal_end_time, 
                      proposal_snapshot_time, proposal_type, voting_power_strategy);

      save_data(registry_address, dao_id, next_proposal_id + 1, owner_address, dao_settings, proposal_code);
      
      return ();
    }

    if (op == OP::UPDATE_DAO_SETTINGS) { ;; update dao settings
      
      var new_dao_settings = in_msg_body~load_ref();
      save_data(registry_address, dao_id, next_proposal_id, owner_address, new_dao_settings, proposal_code);
      
      return ();
    }

    send_opcode(registry_address, op + 0x1000); ;; send notification msg to registry 

  }

;; Get methods
slice get_registry() method_id {
  var (registry_address, _, _, _, _, _) = load_data();
  return registry_address;
}

int get_dao_id() method_id {
  var (_, dao_id, _, _, _, _) = load_data();
  return dao_id;
}

int get_next_proposal_id() method_id {
  var (_, _, next_proposal_id, _, _, _) = load_data();
  return next_proposal_id;
}

slice get_dao_owner() method_id {
  var (_, _, _, owner_address, _, _) = load_data();
  return owner_address;
}

cell get_dao_settings() method_id {
  var (_, _, _, _, dao_settings, _) = load_data();
  return dao_settings;
}
